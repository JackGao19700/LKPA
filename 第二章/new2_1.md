本章我们讲述内存管理，那么究竟什么是内存管理呢？可能有很多人会说内存管理就是段页管理，仅仅是这样的吗？

内存管理，顾名思义就是通过管理提高内存利用率，系统性能等。到底通过什么样的管理方式呢，一定是段页管理吗？本节写者希望能给你答案。

## **2.1 如果给你一段内存你要怎么做？**

在讲所有的技术原理之前，请读者思考一个问题：如果给你一段8G内存，你要怎么管理？

最直观简单的管理就是，完全不管理。进程根据程序员指定的地址，自由遨游在计算机内存中。这种方式简单明了，程序直接操作物理内存，节省CPU资源，早些年操作系统就是这么设计的。这样的管理被历史淘汰掉总是有一定原因的，如果这个系统只运行一个程序，那么只要这个程序所需的内存不要超过该机器的物理内存就不会出现问题，我们也就不需要考虑内存管理这个麻烦事了，反正就你一个程序，就这么点内存，吃不吃得饱那是你的事情了。然而现在的系统都是支持多任务，多进程的，这样CPU以及其他硬件的利用率会更高，这个时候我们就要考虑到将系统内有限的物理内存如何及时有效的分配给多个程序了。

举个例子，用户同时访问浏览器、即时聊天和播放器这三个进程。操作系统的第一要求是正确性，也就是说这三个进程在运行期间不能互相覆盖，三个程序开发人员需要提前规划好那个进程运行在那个空间内。8G内存，假设操作系统占用低2G，浏览器、即时聊天、播放器这三个人商议好均分剩余6G，分别占2G。好的，大家把商议好的地址分别写在自己的代码里打包发布。用户安装，运行期间没有冲突世界和平。这时用户爸爸同时访问的进程中又增加了小游戏，那行吧，重新规划吧。这4个人，又在一起重新分配了内存，修改程序源码打包发布提醒用户升级。用户安装，运行，循环往复。发现什么问题了吗？

首先，这根本不能叫支持多任务、多进程的操作系统，最多算支持指定进程同时运行伪多任务。第二，程序员在程序运行之前需要知道程序包括堆栈数据段代码段等等占多少字节，这就挺难的。想象一下链表排序之前会有人告诉你链表多长吗？第三，不同程序的开发人员商议哪个进程运行在哪段区间，可能吗？

好了，不管理是不行了，那就优化吧。人类对解放劳动力的期望催生了第一次工业革命，可见人类对手工劳动的执念。程序员自己规划程序运行的内存空间，这样的设计显然很反人类。那么第一个优化就是希望操作系统来完成这个工作。至于为什么一定是操作系统，那你总不能让应用程序自己规划吧。经过整理，需求大约是这样的：首先程序告诉系统自己要占多大空间，系统规划好程序运行在什么位置并加载到该位置。所有的开发人员在程序中默认一个起始地址，程序中地址的操作都是对于起始地址而言。比如说`mov reg1,20` 代码真正操作物理地址可能不是20，而是1220等。既然程序中操作的地址不再是物理地址而是虚拟地址，需要操作系统提供一个从虚拟地址->物理地址的转换机制。为了防止程序中操作了内存空间之外的地址，操作系统记录改程序的地址界限。这一套的优化叫做分段管理，每个程序都有其独立的虚拟的独立的进程地址空间，程序A和B的虚拟地址空间都是从0x00000000开始的。我们将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节。

这种分段的机制解决了前面提出的第一和第三个问题——真正的多任务、程序地址重定位。程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A的地址地址空间是0x00000000-0x00A00000，程序访问虚拟地址空间的地址不在这个范围内，那么操作系统就会拒绝这个请求，所以它解决了隔离地址空间的问题。我们应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址我们无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。

无论如何分段机制解决了上面两个问题，是一个很大的进步。然而对于

## **2.2 一定是段页式管理吗？**

答案理所当然是不一定，段页式管理之所以广泛应用是因为合理的满足了需求。设计合理、消耗合理等。如果你想出来更合理的内存三角形管理、内存等腰梯形管理等，一样会取代段页式管理成为另一个划时代的设计。
